<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scryfall Data Visualization Sandbox</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- D3.js for data visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* Custom styles to complement Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-100 */
        }

        /* Custom scrollbar for a better dark mode aesthetic */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }

        /* D3 Tooltip Styling */
        .d3-tooltip {
            position: absolute;
            text-align: center;
            padding: 8px 12px;
            font-size: 0.875rem;
            background: #1f2937; /* bg-gray-800 */
            color: #f9fafb; /* text-gray-50 */
            border: 1px solid #4b5563; /* border-gray-600 */
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        /* Chart container styling for responsive grid */
        .chart-container {
            border: 1px solid #374151; /* border-gray-700 */
        }
    </style>
</head>
<body class="antialiased">

    <!-- Main Application Container -->
    <div class="min-h-screen p-4 sm:p-6 lg:p-8">
        <div class="max-w-7xl mx-auto">

            <!-- Header -->
            <header class="text-center mb-8">
                <h1 class="text-3xl sm:text-4xl font-bold tracking-tight text-white">Scryfall Data Visualization Sandbox</h1>
                <p class="mt-2 text-lg text-gray-400">Build custom charts from any Scryfall query.</p>
            </header>

            <!-- Search Section -->
            <div class="bg-gray-800 p-6 rounded-xl shadow-lg sticky top-4 z-20">
                <div class="flex flex-col sm:flex-row gap-4">
                    <input type="text" id="search-query" placeholder="Enter Scryfall query (e.g., t:dragon year>=2020)" class="flex-grow bg-gray-700 text-white placeholder-gray-400 border border-gray-600 rounded-lg px-4 py-3 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition duration-200">
                    <button id="search-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-6 py-3 rounded-lg transition duration-200 shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-indigo-500 flex items-center justify-center">
                        <svg id="search-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                        <svg id="search-spinner" class="animate-spin h-5 w-5 mr-2 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        Search
                    </button>
                </div>
                <!-- Progress Bar -->
                <div id="progress-container" class="mt-4 hidden">
                    <div id="progress-text" class="text-sm text-gray-300 mb-1 text-center">Loading...</div>
                    <div class="w-full bg-gray-700 rounded-full h-2.5">
                        <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>
                 <!-- Search Error Message -->
                <div id="search-error" class="mt-4 text-center text-red-400 hidden"></div>
            </div>

            <!-- Chart Builder UI -->
            <div id="chart-builder" class="bg-gray-800 p-6 rounded-xl shadow-lg mt-8 hidden">
                <h2 class="text-2xl font-bold mb-4 text-white">Chart Builder</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Chart Type -->
                    <div>
                        <label for="chart-type" class="block text-sm font-medium text-gray-300 mb-1">Chart Type</label>
                        <select id="chart-type" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none">
                            <option value="bar">Bar Chart</option>
                            <option value="pie">Donut Chart</option>
                        </select>
                    </div>
                    <!-- Data Property -->
                    <div>
                        <label for="data-property" class="block text-sm font-medium text-gray-300 mb-1">Data Property</label>
                        <select id="data-property" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none">
                            <option>-- Search first --</option>
                        </select>
                    </div>
                    <!-- Category Limit Wrapper -->
                    <div id="category-limit-wrapper" class="hidden">
                        <label for="category-limit" class="block text-sm font-medium text-gray-300 mb-1">Category Limit</label>
                        <input type="number" id="category-limit" value="15" min="1" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none">
                    </div>
                    <!-- Chart Title -->
                    <div class="md:col-span-2 lg:col-span-3">
                        <label for="chart-title" class="block text-sm font-medium text-gray-300 mb-1">Chart Title (Optional)</label>
                        <input type="text" id="chart-title" placeholder="e.g., 'Card Distribution by Rarity'" class="w-full bg-gray-700 text-white placeholder-gray-400 border border-gray-600 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none">
                    </div>
                </div>
                <!-- Custom Color Mapping -->
                <div id="color-mapper-container" class="mt-4"></div>

                <div class="mt-6 flex justify-end">
                    <button id="add-chart-button" class="bg-green-600 hover:bg-green-700 text-white font-semibold px-6 py-3 rounded-lg transition duration-200 shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-green-500">
                        Add Chart
                    </button>
                </div>
            </div>

            <!-- Dashboard for Charts -->
            <main id="chart-grid" class="grid grid-cols-1 lg:grid-cols-2 2xl:grid-cols-3 gap-6 mt-8"></main>
        </div>
    </div>
    
    <!-- D3 Tooltip Element -->
    <div id="d3-tooltip" class="d3-tooltip"></div>

    <!-- Modal for Card Image Drill-down -->
    <div id="card-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-xl w-full max-w-5xl h-[90vh] flex flex-col shadow-2xl">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h3 id="modal-title" class="text-xl font-semibold text-white">Cards</h3>
                <button id="modal-close" class="text-gray-400 hover:text-white transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <div id="modal-content" class="p-4 flex-grow overflow-y-auto">
                <div id="modal-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                    <!-- Card images will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Notification/Alert Area -->
    <div id="notification-area" class="fixed top-5 right-5 z-[100] flex flex-col items-end gap-2">
        <!-- Notifications will be appended here -->
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- DOM ELEMENT REFERENCES ---
    const searchButton = document.getElementById('search-button');
    const searchInput = document.getElementById('search-query');
    const searchIcon = document.getElementById('search-icon');
    const searchSpinner = document.getElementById('search-spinner');
    const searchError = document.getElementById('search-error');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-text');
    const chartBuilder = document.getElementById('chart-builder');
    const dataPropertySelect = document.getElementById('data-property');
    const addChartButton = document.getElementById('add-chart-button');
    const chartGrid = document.getElementById('chart-grid');
    const chartTypeSelect = document.getElementById('chart-type');
    const categoryLimitWrapper = document.getElementById('category-limit-wrapper');
    const categoryLimitInput = document.getElementById('category-limit');
    const chartTitleInput = document.getElementById('chart-title');
    const colorMapperContainer = document.getElementById('color-mapper-container');
    const tooltip = d3.select("#d3-tooltip");
    const cardModal = document.getElementById('card-modal');
    const modalCloseButton = document.getElementById('modal-close');
    const modalContent = document.getElementById('modal-content');
    const modalTitle = document.getElementById('modal-title');
    const modalGrid = document.getElementById('modal-grid');


    // --- APPLICATION STATE ---
    let allCards = [];

    // --- CORE FUNCTIONS ---

    /**
     * Shows a non-blocking toast notification.
     * @param {string} message - The message to display.
     * @param {boolean} isError - If true, displays as an error (red).
     */
    function showAlert(message, isError = false) {
        const notificationArea = document.getElementById('notification-area');
        const alertId = `alert-${Date.now()}`;
        const bgColor = isError ? 'bg-red-500' : 'bg-indigo-600';

        const alertDiv = document.createElement('div');
        alertDiv.id = alertId;
        alertDiv.className = `max-w-sm rounded-lg shadow-lg text-white text-sm py-2.5 px-4 ${bgColor} transform transition-all duration-300 translate-x-full opacity-0`;
        alertDiv.textContent = message;

        notificationArea.appendChild(alertDiv);

        // Animate in
        requestAnimationFrame(() => {
            alertDiv.classList.remove('translate-x-full', 'opacity-0');
        });

        // Auto-dismiss
        setTimeout(() => {
            alertDiv.classList.add('opacity-0');
            alertDiv.addEventListener('transitionend', () => alertDiv.remove());
        }, 4000);
    }

    /**
     * Fetches card data from the Scryfall API, handling pagination and rate limits.
     * @param {string} query - The Scryfall search query.
     */
    async function fetchScryfallData(query) {
        // Reset UI and state for a new search
        searchError.classList.add('hidden');
        searchError.textContent = '';
        progressContainer.classList.remove('hidden');
        progressText.textContent = 'Initiating search...';
        progressBar.style.width = '0%';
        searchButton.disabled = true;
        searchIcon.classList.add('hidden');
        searchSpinner.classList.remove('hidden');

        let cards = [];
        let next_page_url = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(query)}`;
        let total_cards = 0;

        try {
            while (next_page_url) {
                const response = await fetch(next_page_url);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
                }
                const pageData = await response.json();

                if (!total_cards) {
                    total_cards = pageData.total_cards;
                }
                
                cards.push(...pageData.data);
                
                // Update progress
                const progressPercentage = Math.round((cards.length / total_cards) * 100);
                progressBar.style.width = `${progressPercentage}%`;
                progressText.textContent = `Loading... ${cards.length} / ${total_cards} cards`;
                
                next_page_url = pageData.has_more ? pageData.next_page : null;

                // Respect Scryfall's rate limit
                if (next_page_url) {
                    await new Promise(resolve => setTimeout(resolve, 100)); 
                }
            }

            allCards = cards;
            
            // Post-fetch actions
            clearUnpinnedCharts();
            populateDataPropertyDropdown();
            chartBuilder.classList.remove('hidden');
            progressText.textContent = `Success! Found ${total_cards} cards.`;

        } catch (error) {
            console.error('Scryfall API Error:', error);
            allCards = [];
            chartBuilder.classList.add('hidden');
            searchError.textContent = `Search failed: ${error.message}`;
            searchError.classList.remove('hidden');
            progressContainer.classList.add('hidden');
        } finally {
            // Re-enable search button
            searchButton.disabled = false;
            searchIcon.classList.remove('hidden');
            searchSpinner.classList.add('hidden');
        }
    }

    /**
     * Populates the 'Data Property' dropdown based on available keys in the fetched card data.
     */
    function populateDataPropertyDropdown() {
        if (allCards.length === 0) return;

        const firstCard = allCards[0];
        const validKeys = Object.keys(firstCard).filter(key => {
            const value = firstCard[key];
            return typeof value !== 'object' || Array.isArray(value) || value === null;
        }).sort();

        dataPropertySelect.innerHTML = '<option value="">-- Select a property --</option>';
        validKeys.forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            dataPropertySelect.appendChild(option);
        });
        
        // Hide irrelevant controls initially
        categoryLimitWrapper.classList.add('hidden');
    }

    /**
     * Clears all charts from the grid that are not pinned.
     */
    function clearUnpinnedCharts() {
        const charts = chartGrid.querySelectorAll('.chart-wrapper');
        charts.forEach(chart => {
            if (!chart.dataset.pinned || chart.dataset.pinned === 'false') {
                chart.remove();
            }
        });
    }

    /**
     * Processes the card data based on the selected property and its type.
     * @param {string} property - The card property to analyze.
     * @returns {Array} - An array of objects {label, value} for charting.
     */
    function processData(property) {
        const counts = new Map();
        const firstValue = allCards.length > 0 ? allCards.find(c => c[property] !== undefined && c[property] !== null)?.[property] : undefined;
        const isArray = Array.isArray(firstValue);
        const isNumeric = typeof firstValue === 'number' && !isArray;

        // Special handling for array properties
        if (property === 'colors' || property === 'color_identity') {
            allCards.forEach(card => {
                const colors = card[property] || [];
                let category;
                if (colors.length === 0) {
                    category = 'Colorless';
                } else if (colors.length > 1) {
                    category = 'Multicolor';
                } else {
                    category = colors[0];
                }
                counts.set(category, (counts.get(category) || 0) + 1);
            });
        } else if (isArray) { // Flatten other arrays (e.g., keywords)
            allCards.forEach(card => {
                if (Array.isArray(card[property])) {
                    card[property].forEach(item => {
                         counts.set(item, (counts.get(item) || 0) + 1);
                    });
                }
            });
        } else { // Handle primitive types (string, number, boolean)
            allCards.forEach(card => {
                let value = card[property];
                if (value === null || value === undefined) value = 'N/A';
                counts.set(value, (counts.get(value) || 0) + 1);
            });
        }
        
        let data = Array.from(counts, ([label, value]) => ({ label, value }));
        
        // Sort and limit data
        if (isNumeric) {
            data.sort((a, b) => a.label - b.label);
        } else {
            data.sort((a, b) => b.value - a.value);
            const limit = parseInt(categoryLimitInput.value, 10) || 15;
            data = data.slice(0, limit);
        }
        
        return data;
    }
    
    /**
     * Generates and manages the dynamic color mapping UI.
     */
    function updateColorMapper() {
        colorMapperContainer.innerHTML = '';
        const property = dataPropertySelect.value;
        if (!property) return;

        const firstValue = allCards.length > 0 ? allCards.find(c => c[property] !== undefined && c[property] !== null)?.[property] : undefined;
        // Show color mapper only for categorical (string or special array) data
        const isCategorical = typeof firstValue === 'string' || 
                              (Array.isArray(firstValue)) ||
                              typeof firstValue === 'boolean' ||
                              firstValue === null;

        if (!isCategorical) return;

        const processedData = processData(property);
        if(processedData.length === 0) return;

        const wrapper = document.createElement('div');
        wrapper.className = 'bg-gray-700 p-4 rounded-lg';
        wrapper.innerHTML = `<h4 class="text-md font-semibold mb-3 text-gray-200">Custom Color Mapping</h4>`;
        
        const grid = document.createElement('div');
        grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-x-4 gap-y-2';

        processedData.forEach(({label}) => {
            const item = document.createElement('div');
            item.className = 'flex items-center gap-2';
            item.innerHTML = `
                <input type="color" id="color-${label}" data-label="${label}" class="color-input h-6 w-8 p-0 border-none rounded cursor-pointer bg-transparent" value="${getInitialColor(label, property)}">
                <label for="color-${label}" class="text-sm text-gray-300 truncate" title="${label}">${label}</label>
            `;
            grid.appendChild(item);
        });

        wrapper.appendChild(grid);
        colorMapperContainer.appendChild(wrapper);
    }
    
    /**
     * Provides initial default colors for the color picker.
     * @param {string} label - The data category label (e.g., 'W', 'mythic').
     * @param {string} property - The property being charted.
     * @returns {string} - A hex color code.
     */
    function getInitialColor(label, property) {
        const magicColorMap = {
            'W': '#f8f8f8', 'U': '#5e9fe6', 'B': '#3c3c3c',
            'R': '#e47878', 'G': '#5b9971', 'Multicolor': '#d4af37', 'Colorless': '#a9a9a9'
        };
        if ((property === 'colors' || property === 'color_identity') && magicColorMap[label]) {
            return magicColorMap[label];
        }
        // Fallback to a simple hash function for pseudo-random but consistent colors
        let hash = 0;
        for (let i = 0; i < String(label).length; i++) {
            hash = String(label).charCodeAt(i) + ((hash << 5) - hash);
        }
        let color = '#';
        for (let i = 0; i < 3; i++) {
            const value = (hash >> (i * 8)) & 0xFF;
            color += ('00' + value.toString(16)).substr(-2);
        }
        return color;
    }


    /**
     * Gets the color scale for a chart, prioritizing user input, then special cases, then defaults.
     * @param {string} property - The card property being charted.
     * @param {Array} domain - The array of labels for the chart.
     * @returns {d3.ScaleOrdinal} - A D3 ordinal scale for colors.
     */
    function getColorScale(property, domain) {
        // 1. Check for user-defined colors from the UI
        const colorInputs = colorMapperContainer.querySelectorAll('.color-input');
        const customColorMap = new Map();
        if (colorInputs.length > 0) {
            colorInputs.forEach(input => {
                customColorMap.set(input.dataset.label, input.value);
            });
            // Only use if it has entries
            if (customColorMap.size > 0) {
                 return d3.scaleOrdinal().domain(domain).range(domain.map(d => customColorMap.get(String(d)) || getInitialColor(d, property)));
            }
        }
        
        // 2. Check for Magic: The Gathering specific color properties
        const magicColorMap = {
            'W': 'whitesmoke', 'U': 'skyblue', 'B': 'darkslategray', 
            'R': 'indianred', 'G': 'seagreen', 'Multicolor': 'gold', 'Colorless': 'gray'
        };
        if (property === 'colors' || property === 'color_identity') {
            return d3.scaleOrdinal().domain(domain).range(domain.map(d => magicColorMap[d] || 'purple'));
        }

        // 3. Fallback to a standard D3 color scheme
        return d3.scaleOrdinal(d3.schemeTableau10).domain(domain);
    }

    /**
     * Main function to create and render a chart.
     */
    function createChart() {
        const property = dataPropertySelect.value;
        if (!property) {
            showAlert('Please select a data property to visualize.', true);
            return;
        }

        const chartType = chartTypeSelect.value;
        const data = processData(property);
        if(data.length === 0) {
            showAlert(`No data found for property: ${property}.`, true);
            return;
        }

        const title = chartTitleInput.value || `${property.replace(/_/g, ' ')} Distribution`;

        // Create wrapper for chart and controls
        const chartWrapper = document.createElement('div');
        chartWrapper.className = 'chart-wrapper h-96 bg-gray-800 rounded-xl shadow-lg p-4 flex flex-col relative';
        chartWrapper.dataset.pinned = 'false';
        
        // Save config for pinning
        chartWrapper.dataset.config = JSON.stringify({
            property, chartType, title, limit: categoryLimitInput.value,
        });

        // Add chart controls (pin, delete)
        const controls = document.createElement('div');
        controls.className = 'absolute top-3 right-3 flex gap-2';
        controls.innerHTML = `
            <button class="pin-btn p-2 bg-gray-700 hover:bg-gray-600 rounded-full transition text-gray-300 hover:text-white" title="Pin chart">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
                </svg>
            </button>
            <button class="delete-btn p-2 bg-gray-700 hover:bg-red-500 rounded-full transition text-gray-300 hover:text-white" title="Delete chart">
                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
            </button>
        `;
        chartWrapper.appendChild(controls);

        const chartElement = document.createElement('div');
        chartElement.className = 'flex-grow min-h-0'; // min-h-0 is important for flex-grow in a fixed-height parent
        chartWrapper.appendChild(chartElement);
        
        chartGrid.prepend(chartWrapper);
        
        if (chartType === 'bar') {
            renderBarChart(chartElement, data, title, property);
        } else {
            renderPieChart(chartElement, data, title, property);
        }
    }
    
    // --- D3 RENDERING FUNCTIONS ---
    
    function renderBarChart(container, data, title, property) {
        const colorScale = getColorScale(property, data.map(d => d.label));
        const margin = {top: 40, right: 30, bottom: 100, left: 60};

        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                if (width <= 0 || height <= 0) continue;

                d3.select(container).select('svg').remove();

                const svg = d3.select(container)
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                const w = width - margin.left - margin.right;
                const h = height - margin.top - margin.bottom;

                // X axis
                const x = d3.scaleBand()
                    .range([0, w])
                    .domain(data.map(d => d.label))
                    .padding(0.2);
                
                svg.append("g")
                    .attr("transform", `translate(0,${h})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "translate(-10,0)rotate(-45)")
                    .style("text-anchor", "end")
                    .style("fill", "#9ca3af");

                // Y axis
                const y = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.value)])
                    .range([h, 0]);

                svg.append("g")
                    .call(d3.axisLeft(y))
                    .selectAll("text")
                    .style("fill", "#9ca3af");

                // Bars
                svg.selectAll("mybar")
                    .data(data)
                    .join("rect")
                    .attr("x", d => x(d.label))
                    .attr("y", d => y(0)) // Start at y=0 for transition
                    .attr("width", x.bandwidth())
                    .attr("height", d => 0) // Start at height=0
                    .attr("fill", d => colorScale(d.label))
                    .style("cursor", "pointer")
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1);
                    })
                    .on("mousemove", (event, d) => {
                        const total = d3.sum(data, d => d.value);
                        const percentage = ((d.value / total) * 100).toFixed(1);
                        tooltip.html(`<strong>${d.label}</strong><br>${d.value} cards (${percentage}%)`)
                            .style("left", (event.pageX + 15) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.style("opacity", 0);
                    })
                    .on("click", (event, d) => {
                        showCardModal(d.label, property);
                    })
                    .transition()
                    .duration(800)
                    .attr("y", d => y(d.value))
                    .attr("height", d => h - y(d.value));

                // Title
                svg.append("text")
                    .attr("x", w / 2)
                    .attr("y", 0 - (margin.top / 2))
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("fill", "white")
                    .style("font-weight", "bold")
                    .text(title);
            }
        });
        resizeObserver.observe(container);
    }
    
    function renderPieChart(container, data, title, property) {
        const colorScale = getColorScale(property, data.map(d => d.label));
        const margin = { top: 40, right: 20, bottom: 20, left: 20 };

        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                if (width <= 0 || height <= 0) continue;

                d3.select(container).select('svg').remove();
                
                const w = width - margin.left - margin.right;
                const h = height - margin.top - margin.bottom;
                const radius = Math.min(w, h) / 2;

                const svg = d3.select(container)
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("transform", `translate(${width / 2}, ${height / 2})`);

                const pie = d3.pie()
                    .value(d => d.value)
                    .sort(null);

                const arc = d3.arc()
                    .innerRadius(radius * 0.5) // Donut chart
                    .outerRadius(radius * 0.8);
                
                const outerArc = d3.arc()
                    .innerRadius(radius * 0.9)
                    .outerRadius(radius * 0.9);

                // Slices
                svg.selectAll('allSlices')
                    .data(pie(data))
                    .join('path')
                    .attr('d', arc)
                    .attr('fill', d => colorScale(d.data.label))
                    .attr('stroke', '#1f2937')
                    .style('stroke-width', '2px')
                    .style("cursor", "pointer")
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1);
                        d3.select(event.currentTarget).transition().duration(200).attr('d', d3.arc().innerRadius(radius * 0.5).outerRadius(radius * 0.85));
                    })
                    .on("mousemove", (event, d) => {
                        const total = d3.sum(data, d => d.value);
                        const percentage = ((d.data.value / total) * 100).toFixed(1);
                        tooltip.html(`<strong>${d.data.label}</strong><br>${d.data.value} cards (${percentage}%)`)
                            .style("left", (event.pageX + 15) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", (event, d) => {
                        tooltip.style("opacity", 0);
                        d3.select(event.currentTarget).transition().duration(200).attr('d', arc);
                    })
                    .on("click", (event, d) => {
                        showCardModal(d.data.label, property);
                    })
                    .transition()
                    .duration(800)
                    .attrTween('d', function(d) {
                        const i = d3.interpolate({startAngle: 0, endAngle: 0}, d);
                        return function(t) { return arc(i(t)); };
                    });

                // Title
                d3.select(container).select('svg').append("text")
                    .attr("x", width / 2)
                    .attr("y", margin.top / 2 + 5)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("fill", "white")
                    .style("font-weight", "bold")
                    .text(title);
            }
        });
        resizeObserver.observe(container);
    }
    
    // --- MODAL AND INTERACTIVITY ---

    /**
     * Shows a modal with images of cards matching a specific category.
     * @param {string} categoryLabel - The label of the clicked chart segment.
     * @param {string} property - The property used for filtering.
     */
    function showCardModal(categoryLabel, property) {
        modalGrid.innerHTML = ''; // Clear previous content
        
        const filteredCards = allCards.filter(card => {
            const val = card[property];
            // Handle special array cases
            if (property === 'colors' || property === 'color_identity') {
                const colors = val || [];
                if (categoryLabel === 'Colorless') return colors.length === 0;
                if (categoryLabel === 'Multicolor') return colors.length > 1;
                return colors.length === 1 && colors[0] === categoryLabel;
            }
            if (Array.isArray(val)) {
                return val.includes(categoryLabel);
            }
            // Handle primitive cases
            return String(val) === String(categoryLabel) || ((val === null || val === undefined) && categoryLabel === 'N/A');
        });

        modalTitle.textContent = `${categoryLabel} (${filteredCards.length} cards)`;

        if(filteredCards.length > 0) {
            filteredCards.forEach(card => {
                const imgUrl = card.image_uris?.normal || card.card_faces?.[0]?.image_uris?.normal;
                if (imgUrl && card.scryfall_uri) {
                    const link = document.createElement('a');
                    link.href = card.scryfall_uri;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    
                    const img = document.createElement('img');
                    img.src = imgUrl;
                    img.alt = card.name;
                    img.className = 'w-full rounded-lg shadow-md hover:scale-105 transition-transform duration-200';
                    img.loading = 'lazy';
                    
                    link.appendChild(img);
                    modalGrid.appendChild(link);
                }
            });
        } else {
            modalGrid.innerHTML = `<p class="text-gray-400 col-span-full text-center">No cards with images found for this category.</p>`;
        }
        
        cardModal.classList.remove('hidden');
    }

    // --- EVENT LISTENERS ---
    searchButton.addEventListener('click', () => {
        const query = searchInput.value.trim();
        if (query) {
            fetchScryfallData(query);
        } else {
            showAlert('Please enter a search query.', true);
        }
    });

    searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            searchButton.click();
        }
    });

    addChartButton.addEventListener('click', createChart);
    
    dataPropertySelect.addEventListener('change', () => {
        const property = dataPropertySelect.value;

        if (!property) {
            categoryLimitWrapper.classList.add('hidden');
            updateColorMapper();
            return;
        }

        const firstValue = allCards.length > 0 ? allCards.find(c => c[property] !== undefined && c[property] !== null)?.[property] : undefined;
        const isNumeric = typeof firstValue === 'number' && !Array.isArray(firstValue);

        if (isNumeric) {
            categoryLimitWrapper.classList.add('hidden');
        } else {
            categoryLimitWrapper.classList.remove('hidden');
        }
        
        updateColorMapper();
    });
    
    categoryLimitInput.addEventListener('input', updateColorMapper);

    modalCloseButton.addEventListener('click', () => cardModal.classList.add('hidden'));
    cardModal.addEventListener('click', (e) => {
        if (e.target === cardModal) { // Close if clicking on the backdrop
            cardModal.classList.add('hidden');
        }
    });
    
    // Event delegation for chart controls
    chartGrid.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('.delete-btn');
        const pinBtn = e.target.closest('.pin-btn');

        if (deleteBtn) {
            deleteBtn.closest('.chart-wrapper').remove();
        }

        if (pinBtn) {
            const chartWrapper = pinBtn.closest('.chart-wrapper');
            const isPinned = chartWrapper.dataset.pinned === 'true';
            chartWrapper.dataset.pinned = !isPinned;
            pinBtn.classList.toggle('bg-indigo-500', !isPinned);
            pinBtn.classList.toggle('bg-gray-700', isPinned);
            pinBtn.classList.toggle('text-white', !isPinned);
            pinBtn.title = isPinned ? 'Pin chart' : 'Unpin chart';
        }
    });
});
</script>

</body>
</html>
